<?php
declare(strict_types=1);

namespace SetBased\Audit\Test\MySql\AuditCommand\LockTable;

use SetBased\Audit\Command\AuditCommand;
use SetBased\Audit\MySql\AuditDataLayer;
use SetBased\Audit\Test\MySql\AuditTestCase;
use Symfony\Component\Console\Application;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Tester\CommandTester;

/**
 * Tests for table locking.
 */
class LockTableTestCase extends AuditTestCase
{
  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Connects to the MySQL server.
   */
  public static function setUpBeforeClass(): void
  {
    parent::setUpBeforeClass();

    AuditDataLayer::$dl->executeMulti(file_get_contents(__DIR__.'/config/setup.sql'));
  }

  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Test locking table is in verbose output.
   */
  public function test01(): void
  {
    $application = new Application();
    $application->add(new AuditCommand());

    /** @var AuditCommand $command */
    $command = $application->find('audit');
    $command->setRewriteConfigFile(false);
    $commandTester = new CommandTester($command);
    $commandTester->execute(['command'     => $command->getName(),
                             'config file' => __DIR__.'/config/audit.json'],
                            ['verbosity' =>
                               OutputInterface::VERBOSITY_NORMAL |
                               OutputInterface::VERBOSITY_VERBOSE |
                               OutputInterface::VERBOSITY_VERY_VERBOSE]);

    $status = $commandTester->getStatusCode();
    self::assertSame(0, $status, 'status code');

    $output = $commandTester->getDisplay();
    self::assertStringContainsString('lock tables `test_data`.`TABLE1` write', $output, 'acquire');
    self::assertStringContainsString('unlock tables', $output, 'release');
  }

  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Test that the table is actually locked.
   */
  public function test02(): void
  {
    $application = new Application();
    $application->add(new AuditCommand());

    // Start process that inserts rows into TABLE1.
    $pid = pcntl_fork();
    if ($pid==0)
    {
      // Child process.
      pcntl_exec(__DIR__.'/config/generator.php');
    }
    // Parent process.
    sleep(2);

    /** @var AuditCommand $command */
    $command = $application->find('audit');
    $command->setRewriteConfigFile(false);
    $commandTester = new CommandTester($command);
    $commandTester->execute(['command'     => $command->getName(),
                             'config file' => __DIR__.'/config/audit.json']);

    // Tell the generator it is time to stop.
    posix_kill($pid, SIGUSR1);

    $status = $commandTester->getStatusCode();
    self::assertSame(0, $status, 'status code');

    pcntl_waitpid($pid, $status);
    self::assertEquals(0, $status);

    // Reconnect to DB.
    AuditDataLayer::$dl->connect();

    // It can take some time before that all rows generated by $generator are visible by this process.
    $n1 = 0;
    $n2 = 0;
    sleep(5);
    for ($i = 0; $i<60; $i++)
    {
      $n1 = AuditDataLayer::$dl->executeSingleton1("select AUTO_INCREMENT - 1 
                                                from information_schema.TABLES
                                                where TABLE_SCHEMA = 'test_data'
                                                and   TABLE_NAME   = 'TABLE1'");
      $n2 = AuditDataLayer::$dl->executeSingleton1('select count(*) from test_audit.TABLE1');

      if ((4 * $n1)==$n2) break;

      sleep(3);
    }

    self::assertEquals(4 * $n1, $n2, 'count');
  }

  //--------------------------------------------------------------------------------------------------------------------
}

//----------------------------------------------------------------------------------------------------------------------
